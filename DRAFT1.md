# DDD


# 自分の意見

<aside>
⚠️

前提

- ドメイン知識をコードに落とし込むべき、という戦略的な概念は同意できる
- 集約や値オブジェクト、エンティティといった戦術的な概念が必要かと言うと微妙（理由は後述）
- 書き込みのスケーラビリティを確保するために非同期処理・結果整合性・べき等とセットで採用するならアリ（だがDDDは無くても成立する）
    - [DDDと非同期処理・結果整合性・べき等](https://www.notion.so/DDD-202b12fb62748158847bc731ee79255e?pvs=21)

</aside>

- RDB+ORMと相性悪い気がする
    - RDB上にドメイン知識に基づいたデータモデルを作る
    - クエリにもドメイン知識は含まれる
        - 「レポジトリにはドメイン知識が含まれないためドメインモデルだけテストすれば良い」は幻想。クエリの条件式でバグる。
    - ドメインモデルとデータモデルがわりと重複する
        - データの詰替えでナンセンスさを感じる
- Webのバックエンドとも相性が悪い（コスパが悪い）
    - 否定派の意見
        - 渋川よしきさんの意見
            - [https://twitter.com/search?q=%40shibu_jp DDD&src=typed_query](https://twitter.com/search?q=%40shibu_jp%20DDD&src=typed_query)
            - [https://twitter.com/search?q=%40shibu_jp ドメイン駆動&src=typed_query&f=live](https://twitter.com/search?q=%40shibu_jp%20%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95&src=typed_query&f=live)
        - kumagiさん
            - [https://twitter.com/search?q=%40kumagi DDD&src=typed_query&f=live](https://twitter.com/search?q=%40kumagi%20DDD&src=typed_query&f=live)
            - [https://twitter.com/search?q=%40kumagi ドメイン駆動&src=typed_query&f=live](https://twitter.com/search?q=%40kumagi%20%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95&src=typed_query&f=live)
            - [https://twitter.com/little_hand_s/status/1557238535442542592](https://twitter.com/little_hand_s/status/1557238535442542592)
            - 
            
            ![image.png](image.png)
            
            ![[https://x.com/shibu_jp/status/1790522057899540520](https://x.com/shibu_jp/status/1790522057899540520)](image%201.png)
            
            [https://x.com/shibu_jp/status/1790522057899540520](https://x.com/shibu_jp/status/1790522057899540520)
            
            ![[https://x.com/shibu_jp/status/1835465143381373065](https://x.com/shibu_jp/status/1835465143381373065?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1835465143381373065%7Ctwgr%5E9764d9fecc35f1216e1da25bcafe10c43157fd31%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fwww.notion.so%2Ft-kuni%2FDDD-b0de66b9d6844d8bb57f12d6b5443c50)](image%202.png)
            
            [https://x.com/shibu_jp/status/1835465143381373065](https://x.com/shibu_jp/status/1835465143381373065?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1835465143381373065%7Ctwgr%5E9764d9fecc35f1216e1da25bcafe10c43157fd31%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fwww.notion.so%2Ft-kuni%2FDDD-b0de66b9d6844d8bb57f12d6b5443c50)
            
    - Webバックエンドとエンティティの相性
        
        ### DDD適用に対する懸念と運用上の前提について
        
        現在のWebバックエンド開発において、DDD（ドメイン駆動設計）をそのまま適用することに対し、効率面や実装の自然さに疑問があります。
        
        特に「エンティティを正しく運用するために必要な前提手順」への認識が不足していると感じています。
        
        ---
        
        ### ◆ エンティティを使った更新処理の前提手順
        
        DDDにおけるエンティティは「ビジネスルールを内包する主体」として扱われるため、更新処理では次の手順が原則となります：
        
        1. **DBから対象のエンティティを復元する**
            
            （＝現在の正しい状態をメモリ上に再構成する）
            
        2. **リクエストに基づいてエンティティの操作メソッドを呼び出す**
            
            （＝値の更新やビジネスルールの検証を実行）
            
        3. **変更されたエンティティをDBに反映する**
            
            （＝集約ルート単位で永続化）
            
        
        この手順を踏まないと、エンティティの責務（ルールの一貫性保持、状態遷移の管理）を果たせません。
        
        ---
        
        ### ◆ DDDに対する現実的な課題
        
        しかしながら、Webバックエンドの性質上、以下のような点でこの運用が難しい・非効率に感じられます：
        
        - 多くの処理は「集約内で完結しない」
            
            例：メールアドレスの重複チェックのように、**他のレコードとの整合性が必要なケース**が多く、エンティティ単体では判断できない。こうした処理はリポジトリやドメインサービスに委ねざるを得ない。
            
        - 処理の多くは「ステートレスなAPI呼び出し」であり、**一時的な単発操作が中心**
            
            そのため、都度エンティティを復元・操作・保存する流れは過剰となりがち。
            
        - 結果として、**エンティティを中心とした設計が形骸化しやすく、実装コストばかりが増える**
        
        ---
        
        ### ◆ 提案
        
        - 上記の理由から、**すべての処理に対してエンティティ中心の設計を強制すべきではない**と考えます。
        - **値オブジェクトや必要最小限のドメインサービス**に留め、**ユースケース単位で手続き的に処理を記述する構成**を基本としたい。
        - 設計原則は「複雑さに見合った投資」を前提とし、**DDDはドメインが複数集約にまたがるような複雑な領域にのみ選択的に適用**する形を推奨します。
    - 図
        - [https://app.diagrams.net/index.html#G1A3BjiJeQH2nIU8qOLje75C8XH0L7ODv8#{"pageId"%3A"Mc5j2YI3X4_bWZdBPDcj"}](https://app.diagrams.net/index.html#G1A3BjiJeQH2nIU8qOLje75C8XH0L7ODv8#%7B%22pageId%22%3A%22Mc5j2YI3X4_bWZdBPDcj%22%7D)
            
            ![色々のプログラムの形態.drawio.png](%25E8%2589%25B2%25E3%2580%2585%25E3%2581%25AE%25E3%2583%2597%25E3%2583%25AD%25E3%2582%25B0%25E3%2583%25A9%25E3%2583%25A0%25E3%2581%25AE%25E5%25BD%25A2%25E6%2585%258B.drawio.png)
            
        - スタンドアロンなデスクトップアプリケーションでは
            - まとまった単位でメモリに読み込み → メモリ上ではクラス/インスタンスとして各種操作を行う → まとまった単位でファイルの保存
            - 
                - 
        - Webバックエンドでは
            - リクエスト単位でメモリが揮発
            - DB上の状態全量をメモリに載せられない
            - SQL（取得、更新）にもドメイン知識が乗ってくる
                - 主にWHERE句など
                    - 相関チェックでよくある「重複データが存在しない事」などはSQLにドメイン知識が乗る典型
                - パフォーマンスのために複雑なクエリになる事もある
            - DDDはドメイン知識をドメイン層に集めて、ドメイン層（インメモリの処理のみ）を検証する事で品質を上げる思想だが、
            - DBだけではなく外部サービスなどの副作用(I/O)の扱いをどうするか？という話の比重が増す
        - Webバックエンドの関心の中心
            - 認証
            - 認可
            - バリデーション
    - 多くはRDB上に状態を持っている
        - 単体で動作するデスクトップアプリの場合、メモリ上に完全な状態を保持しておく事が可能だが、Webバックエンドは大抵RDBに状態があり、リクエスト単位に状態を復元する必要がある（後述のDDDのトリレンマにつながる）
    - 1機能を複数のAPIで実現する
        - API１つ１つはそれほど複雑にならない
    - デスクトップアプリケーションの方がメリットが大きい
- 相関バリデーションで集約が肥大化する or ドメインサービスになる
    - ロジックが大幅に変わる（変更が容易とは言えない）
    - 詳細
        
        ![image.png](image%203.png)
        
        ![image.png](image%204.png)
        
        ![image.png](image%205.png)
        
- 大量に更新するときも集約が肥大化する or ドメインサービスになる
    - 詳細
        
        ![image.png](image%206.png)
        
- ドメインモデル貧血症になるのではないか？
    - それはMVC時代の問題
        - １つのエンドポイントで１つの画面全体をレンダリングしていた時代にはたしかにあった
- レイヤー毎に似た構造体を定義する
    - 詰替えミスでバグ
    - 項目の抜け漏れ
    - 共通化したいと言い出すやつがいる
- DDDの提唱は2003年
    - 2003年の主流なソフトウェアはオフィスやフォトショなどのスタンドアロンなデスクトップアプリ
- DDDはソフトウェア全般に言及している
    - Webバックエンドに限定して話しているわけではない
        - Webバックエンドに適しているとは言っていない
    - ソフトウェアにもいろいろある
        - デスクトップアプリケーション
        - モバイルアプリケーション
        - 組み込みソフト
        - Webフロントエンド
        - Webバックエンド
        - ジョブ
        - （何らかに付随する）拡張機能
        - ライブラリ
- 学習コストが高い
    - チーム全員の共通理解が難しい
    - 人それぞれの考えるベストが異なる
        - 設計に一貫性がなくなる
    - そこまでのモチベーションがない人もいる
    - ある処理をどのモデルに生やすのか？でいちいち議論になる
        - 時間の無駄
    - DDDで燃え尽きてテストが書かれてない
        - 本末転倒
- ルールが多く遵守するコストが高い
    - ルールを遵守するにもコストがかかる
        - レビューで拾うなど
    - 
- 手段が目的化している
    - 「バグを減らしたい」「生産性を高めたい」がゴールである
        - DDDの議論で時間を取られて本質と向き合えないのは本末転倒
- 業務をシステム化する時代が終わった
    - システムから業務が生まれる時代
        - 少なくとも 業務 → システム という一方通行ではない
            - ドメインエキスパートとは誰？という問題
            - ドメインエキスパートがいない？お前がなるんだよ。という時代になった
                
                ![[https://qiita.com/shibukawa/items/2698b980933367ad93b4#dddという負け犬](https://qiita.com/shibukawa/items/2698b980933367ad93b4#ddd%E3%81%A8%E3%81%84%E3%81%86%E8%B2%A0%E3%81%91%E7%8A%AC)](image%207.png)
                
                [https://qiita.com/shibukawa/items/2698b980933367ad93b4#dddという負け犬](https://qiita.com/shibukawa/items/2698b980933367ad93b4#ddd%E3%81%A8%E3%81%84%E3%81%86%E8%B2%A0%E3%81%91%E7%8A%AC)
                
            - 
- 複雑な処理の多くはインフラストラクチャの都合から生まれる
    - 単にエンドユーザからの要望をそのまま落とし込めるならさほど難しくない
    - 「N+1問題」や「外部のAPIのクォータ」などの考慮によりプログラムが複雑になる
    - 上記の問題を「モデルにフィードバックする」必要があるという事を大抵の人は理解せずにDDDをやろうとしている
        - エヴァンスのドメイン駆動設計（p57）
    - ドメインモデリングをトップダウンでやるとそれらをモデルとして見つけるのは難しい
- 複雑なロジックはインフラストラクチャの都合で生まれることがおおい
    - 例
        - 処理の高速化のため、１件づつではなく複数件まとめて処理する必要がある
        - メモリ効率のためページングする必要がある。
    - これらはドメイン知識方面からアプローチしても整理・体系化できない
        - 実装からリバースする必要がある
- ドメインモデルがなくてもデータモデルがあれば事足る
- DDDをやった、やらない、で品質、デリバリー速度が改善したか比較できない
- いうほどドメインモデルに閉じた処理がなくね？
    - 金融系などで、金額に対して複雑な計算が発生するならまだ分かる
    - 複雑な処理は複数のドメインモデルを操作することがおおい → 結局サービスでは？
    - 
- ドメインモデルに純粋性を求めるとDBアクセスは書けなくて、書くことほとんどなくね？
    - 相関チェックがモデル内に閉じないケースが多い
        - カプセル化も損なわれる
    - DBアクセスをrepositoryに書くならシンプルなレイヤードと
    - 別にモデルに書かれていないといけないかと言うとそうでもない
- バリデーションエラーもドメイン層とプレゼンテーション層の間で詰替えが必要
- DDDを支援するフレームワークがない
- 「DDD」には興味があるけど「ドメイン知識」には興味がない人が量産される
    - ドメイン知識を共有する手段は必ずしもドメインモデルだけではない
- 図表を交えたドキュメントの方が低コストに作成でき読む側の認知コストも削減できる
    - 必ずしもドメイン知識を全てロジックから読み取る必要はない
- Webバックエンドの変更の難しさは永続化層の変更の難しさに行き着く
    - 既にデータが入っている状態でスキーマを大幅にリファクタをするのが難しい。
    - 永続化層を抽象化しました、と言っても現実には永続化層に状態を保持している訳で、永続化層のスキーマ構成に起因したパフォーマンスの問題をアプリケーションで解決しようとしても無理。
- 簡単なAPIだと手間が増えるだけ
- 

# 調査メモ

- DDDのトリレンマ
    - [https://scrapbox.io/kawasima/ドメインモデルの完全性と純粋性](https://scrapbox.io/kawasima/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E5%AE%8C%E5%85%A8%E6%80%A7%E3%81%A8%E7%B4%94%E7%B2%8B%E6%80%A7)
    
    ![Untitled](Untitled.png)
    
- 全レコードを読んできてアプリケーション側でフィルタするパターン
    - [https://bamboo-yujiro.hatenablog.com/entry/2020/03/21/215005](https://bamboo-yujiro.hatenablog.com/entry/2020/03/21/215005)
    - ドメイン知識がリポジトリに漏れる