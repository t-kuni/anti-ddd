# DDDとWebバックエンドの相性

以下は記事「DDDとWebバックエンドの相性」の下書きです

以下のルールで記事を書きます

- 基本的にはですます調で記載する。しつこくなる時は体現止めも上手く使う。
- 対象読者はITエンジニア
- 自身はドメイン駆動開発がWebバックエンドに相性が悪いと感じており、その理由を説明することで無思考にドメイン駆動開発が採用される現状に一石を投じたい
- 自身の考えは以下のページに乱雑にまとめています。これを整理して記事にしたいです
    - [https://www.notion.so/t-kuni/DDD-b0de66b9d6844d8bb57f12d6b5443c50](DDD%20b0de66b9d6844d8bb57f12d6b5443c50.md)
- 句点の後は改行する
- なるべく箇条書きで分かりやすく伝える
- 図が合ったほうがわかりやすい箇所には　（図）　と書く

---

# 前提

ビジネスの知識を

ドメインモデリング → エンティティ作成　なんか上手く行かない　よく見かける

<aside>
⚠️

目的

DDDはイマイチだと思わせたい

みなさんがやりたがる、オブジェクト間のメッセージパッシングで完結させるのは難しい

</aside>

どこが相性が悪いか？

1. Webバックエンドはステートレス
2. 認証・認可・バリデーション・本筋の処理
    1. 認可・バリデーション・本筋の処理を全て考慮すると集約・エンティティには閉じにくい
        1. 結局ドメインサービスを使うことになる
3. インフラストラクチャの都合に引っ張られる
    1. 必然的にドメインモデルから乖離した手続きが出てくる
4. 複数のAPIの連携で１つの業務を遂行する
5. 永続化層の変更の難しさ
6. クエリの条件式にもドメイン知識は含まれる
7. 日本式管理手法との相性の悪さ

# ソフトウェアの種類

ソフトウェアと言っても色々あります

例えばスタンドアロンなデスクトップアプリでは状態の多くをメモリ上で管理します

昨今では完全にスタンドアロンなデスクトップアプリはなかなか無いですがDDDが提唱された2003年当時は

![image.png](image%208.png)

この場合、UIを操作するたびに状態が更新されていきます

インタラクション毎にエンティティを更新すればよい

![image.png](image%209.png)

DDDの戦術的なテクニックで言うとメモリ上にエンティティが保持されており、操作のたびにエンティティが更新されていきます

## Webバックエンドはステートレス

Webバックエンドの場合、状態を保持するのはDBになります

またWebバックエンドはステートレスであるためリクエストのたびにメモリ上の状態は揮発します

![image.png](image%2010.png)

つまり、更新リクエストの場合、①DBから集約・エンティティを復元、②集約・エンティティを操作、③集約・エンティティをDBに保存という３ステップをリクエストのたびに行う必要があります

![image.png](image%2011.png)

前述のデスクトップアプリと後述のWebバックエンドを見比べるとWebバックエンドの効率の悪さを感じると思います。

## 全ての状態をメモリ（エンティティ）に復元できない

また、DB上には膨大な状態が蓄積されており、全ての状態をメモリ上に復元できる訳ではありません。

![image.png](image%2012.png)

つまり、メールアドレスの重複チェックなどはメモリ上（エンティティ）で処理する事はできず、DBに処理を移譲することになります。（ドメインサービスやレポジトリに実装する）

（アプリケーション側で整合性を担保したいDDDの思想と相性が悪い）

TODO　シンプルに更新する場合の図？

Webバックエンドの上記の性質を考慮するとWebバックエンドでエンティティを実装するのは費用対効果が微妙に感じます。

増える考慮事項に対してメリットが少ない

# MVCとCRS（クライアントサイドレンダリング）

DDDが提唱された頃はMVCであった

かつてのWebシステムはMVC（バックエンドでHTMLを構築して返却する）でした。

MVCでは１つのエンドポイントで画面全体のパーツ（ヘッダー・フッター・サイドバー・コンテンツ等）を扱っていました。

CRSになってAPIの粒度が小さくなった（API１つ１つはそれほど複雑ではない）

ドメイン知識が複数のAPIに分散するようになった

API間の辻褄合わせが必要になった

APIに分ける都合でドメインモデルに対する実装も分割されたりする

# プログラムが複雑化するタイミング

- 多くは**インフラストラクチャ層に起因**する
    - 例
        - S3にアップロード（PresignedURLを発行したり）
        - N＋１問題の回避
        - 外部サービスのクォータ上限
- インフラストラクチャ層の都合でAPIを分割したり、非同期処理にオフロードしたり等が発生する
- つまり**ドメインモデリングを頑張ればプログラムがシンプルになるとは限らない**
- ビジネスの都合とシステムの都合、両方を考慮したモデリングが必要
- を合わせてできた複雑な手続きを抽象化・共有知化する必要がある
    - （図）

# 単方向のドメインモデリングは誤り

前述したとおり、ビジネスの都合だけを落とし込んでドメインモデリングをしたとしてもそのまま実装に落とし込めることは少ない

- ビジネスの都合とシステムの都合、両方を考慮したモデリングが必要
- 一方で、実装前にシステムの都合を全てモデリングに反映するのは難しい
    - **まずはビジネスの都合に忠実に実装し、後で永続化などを考慮してリファクタリング**する流れでこそ、実質的なドメインモデリングになる。
- 原著でも、**進化的なモデリング**、**継続的なリファクタリング**、**インフラ層との対話の必要性**が強調されている。
- 「モデル」とは**エンティティに限らず**、値オブジェクト、サービス、集約など**ドメインの意味を表す構造全体**を指す。
- ビジネス・システムの都合を織り込んでできた手続きも、**意味づけされていればドメインモデルに含まれる**。
- ドメインモデルは**オブジェクト間のメッセージパッシングに限定されず**、本質は**ドメインの意味とルールの構造的表現**である。

# ドメインモデルを考えました

それはスタート地点でしかない。

じゃあそれをどうやってシステムに落とし込みましょうか？

そのフロー・状態遷移をどう実現しましょうか？

が、一番難しいし、考えないといけないところである。

# ドメインモデル貧血症は起こりにくくなった

- ドメインモデル貧血症とは？
    
    > ドメインモデル貧血症とは、オブジェクト指向設計において、ドメインオブジェクトがデータ（プロパティ）だけを持ち、ビジネスロジックを持たない状態を指します。ビジネスロジックがサービス層などに集中し、オブジェクトが「貧血」状態になることからこの名がついています。
    > 
    - つまり**オブジェクト間のメッセージパッシングでビジネスロジックを表現しろ**と言っている
        - SOLID原則のSRPとの矛盾
    - DDDとセットで2003年に提唱された
- MVC（バックエンドでHTMLを作成する）の場合、コントローラが肥大化することはあった
    - １つのエンドポイントでヘッダー・フッター・サイドバー・コンテンツを扱ったりしていた
- 今はフロントエンドと分離され、エンドポイントの粒度が小さくなったためコントローラが肥大化することはあまり無くなった
    - ヘッダー、フッター、サイドバー、コンテンツ、大抵はそれぞれ別のAPIを呼び出す

# 永続化層の変更の難しさに行き着く

# クエリの条件式にもドメイン知識は含まれる

# ルールを遵守する難しさ

# Webバックエンドの変更の難しさ

永続化層の変更の難しさに行き着く

# データモデル

---

## はじめに

私は普段からWebバックエンドの開発に携わっています。

最近、多くのプロジェクトでドメイン駆動開発（DDD）が採用されていますが、その適用については慎重に検討する必要があると感じています。

DDDの戦術的なテクニック（エンティティ、値オブジェクト、集約、リポジトリなど）とWebバックエンドの相性が懐疑的

DDDのドメインの知識をコードに落とし込むという思想はもちろん必要だと思っています。

### ソフトウェアの多様性とDDD

DDDはソフトウェア開発全般に対する設計手法として提唱されています。ソフトウェアには以下のような様々な形態があります：

- デスクトップアプリケーション
- モバイルアプリケーション
- 組み込みソフトウェア
- Webアプリケーション
    - フロントエンド
    - バックエンド
- バッチ処理やジョブ
- 拡張機能やプラグイン
- ライブラリやフレームワーク

DDDが提唱された2000年代初頭は、スタンドアロンなデスクトップアプリケーションが主流でした。これらの環境では以下の特徴があります：

- メモリ上でオブジェクトの状態を保持し続けることができる
- ドメインモデルが単一のプロセス内で完結する
- データの整合性をオブジェクトの状態として管理できる

一方、Webバックエンドは本質的に異なる性質を持っており、DDDとの相性には課題があると考えています。その理由について、本記事で詳しく説明していきます。

## DDDの基本的な考え方

私の考えるDDDの重要な点は以下の通りです：

- ドメイン知識をコードで表現するという考え方自体は素晴らしいものです
- しかし、集約やエンティティといった具体的な実装パターンについては、慎重に検討する必要があると考えています

## Webバックエンドにおける課題

### 1. RDBとORMとの相性の問題

- RDBには既にドメイン知識が反映されていることが多いです
- クエリにもドメインの考え方が含まれます
    - 「レポジトリにドメイン知識は含まれない」という理想論は現実的ではないと感じています
    - 実際には、クエリの条件指定でバグが発生することが多いです
- ドメインモデルとデータモデルが重複することで、余計な工数が発生してしまいます

### 2. Webバックエンドの特性との不整合

- リクエストごとにメモリが消えるステートレスな特徴があります
- DBの全データをメモリに載せることができません
- 複雑な処理の多くは技術的な制約から生まれます
    - N+1問題への対応が必要になります
    - 外部APIの利用制限を考慮しなければなりません
    - パフォーマンスのために複雑なクエリを書かざるを得ないことがあります

### 3. 実装上の課題

- 学習コストが高すぎると感じています
    - チーム全員が同じように理解することが難しいです
    - 人によってベストプラクティスの解釈が異なってしまいます
- ルールを守るためのコストが高くなってしまいます
- ドメインモデルを純粋に保とうとするとDBアクセスが書けなくなります
    - 他のレコードとの整合性チェックがモデル内で完結しないことが多いです

### ドメインモデル貧血症について

- MVC時代（バックエンドでHTMLを作成していた頃）には意味がありました
    - 1つのエンドポイントで画面全体の情報を扱っていたためです
- 今はフロントエンドと分離され、エンドポイントの役割が限定的になっています

## エンティティの運用における現実的な課題

DDDではエンティティを「ビジネスルールを持つ主体」として扱いますが、Webバックエンドでは以下のような課題を感じています：

- 複雑なドメインロジックはエンティティに閉じないことが多い
    - メールアドレスの重複チェックのように、他のレコードとの整合性が必要なケースが多く、エンティティ単体では判断できません
- ほとんどの処理は「一時的なAPI呼び出し」であり、その都度エンティティを復元・操作・保存する流れは大げさすぎると感じています

## 現代のWeb開発における考慮点

- 今は業務をシステム化する時代から、システムから業務が生まれる時代に変わってきています
    - ドメインエキスパートの定義が変化してきています
    - システムと業務が相互に影響し合っています
- ドメイン知識の共有には必ずしもドメインモデルが最適とは限りません
    - 図表を使ったドキュメントの方が分かりやすい場合もあります
    - 全てのドメイン知識をコードから読み取る必要はないと考えています

## 提案：現実的なアプローチ

これらの課題を踏まえ、私は以下のようなアプローチを提案します：

- 値オブジェクトと最小限のドメインサービスに留めることをお勧めします
- ユースケースごとに手続き的に処理を書く方法を基本にします
- DDDは複雑なドメインロジックがある部分だけに限定して使います
- バリデーションやエラー処理は実用性を重視します

## 結論

私はDDDの考え方自体は価値があると考えていますが、Webバックエンドでは全面的な適用よりも、必要な部分に限定して使う方が現実的だと感じています。特に、「バグを減らしたい」「開発効率を上げたい」という本来の目的を見失わないことが大切です。DDDは手段であって目的ではありません。プロジェクトの特性に応じて柔軟に使い分けていくべきだと考えています。